import process from 'node:process';
import childProcess from 'node:child_process';
import fs from 'node:fs';
import path from 'node:path';

import type { ResolvedConfig } from 'vite';

type ReducedResolvedConfig = Pick<ResolvedConfig, 'root' | 'publicDir'>;

type Paths = {
    filenameWithoutTexExtension: string;
    tmpDirPath: string;
    fileOriginPath: string;
    dirDestPath: string;
    fileDestPath: string;
    uri: string;
};

export type viteTexLoaderOptions = {
    /**
     * Path to GhostScript lib (not executable)
     */
    LIBGS?: string;
    /**
     * CLI options to pass to the `latex` executable
     */
    svgLatexCliOptions?: string;
    /**
     * CLI options to pass to the `dvisvgm` executable
     */
    svgDvisvgmCliOptions?: string;
    /**
     * CLI options to pass to the `pdflatex` executable
     */
    pdfPdflatexCliOptions?: string;
};
type UriOptions = {
    dvisvgmPrefix?: string;
};
type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };
type viteTexLoaderOptionsMandatory =
    & WithRequired<
        viteTexLoaderOptions,
        keyof viteTexLoaderOptions
    >
    & UriOptions;
function convertOptionsToMandatory(
    options: viteTexLoaderOptions,
): viteTexLoaderOptionsMandatory {
    return {
        LIBGS: options.LIBGS ?? '',
        svgLatexCliOptions: options.svgLatexCliOptions ?? '',
        svgDvisvgmCliOptions: options.svgDvisvgmCliOptions ?? '',
        pdfPdflatexCliOptions: options.pdfPdflatexCliOptions ?? '',
    };
}
function readUriParams(params: string): Map<string, string> {
    const map = new Map<string, string>();
    const splittedParams = params.split('&')
        .filter((s) => s.match(/.+=.+/) !== null)
        .map((s) => s.split('='));
    for (const [key, value] of splittedParams) {
        if (key && value) {
            map.set(key, value);
        }
    }
    return map;
}

function hasStdout(e: unknown): e is { stdout: ArrayBuffer } {
    return (e instanceof Object || typeof e === 'object') && e !== null &&
        Object.hasOwn(e, 'stdout');
}

function readContent(filename: string) {
    return fs.readFileSync(filename).toString().replace(
        /<!-- This file was generated by dvisvgm \d+\.\d+\.\d+ -->\n/,
        '',
    );
}

function getPaths(
    config: ReducedResolvedConfig,
    fileOriginPath: string,
    fileExtension: string,
): Paths {
    const dirPath = path.dirname(fileOriginPath);
    const filename = path.basename(fileOriginPath);
    const relativeFolderPath = dirPath.replace(
        path.normalize(`${config.root}/`),
        '',
    );
    const fileExtensionMatch = filename.match(/^(.*)\.tex$/);
    if (!fileExtensionMatch) {
        throw new Error('The file is not a .tex file.');
    }
    const filenameWithoutTexExtension = fileExtensionMatch[1] as string;
    const viteTexLoaderTmpDirPath = `${config.root}/.vite-tex-loader`;
    const tmpDirPath = `${viteTexLoaderTmpDirPath}/${
        dirPath.replace(config.root, '')
    }`;
    const dirDestPath =
        `${config.publicDir}/.auto-generated/${relativeFolderPath}`;
    const fileDestPath =
        `${dirDestPath}/${filenameWithoutTexExtension}.${fileExtension}`;
    const uri = fileDestPath.replace(`${config.root}/public/`, '');
    return {
        filenameWithoutTexExtension,
        tmpDirPath,
        fileOriginPath,
        dirDestPath,
        fileDestPath,
        uri,
    };
}

function newVersion(fileOriginPath: string, fileDestPath: string) {
    try {
        const statTex = fs.statSync(fileOriginPath);
        const statPdf = fs.statSync(fileDestPath);
        const modifiedDateOrigin = statTex.mtime;
        const modifiedDateDest = statPdf.mtime;
        if (modifiedDateOrigin <= modifiedDateDest) {
            // No need to regenerate the file
            return false;
        }
    } catch (_) {
        // statSync didn't work on the file => it does not exist, we consider it is outdated
    }
    return true;
}

function findGhostScript(libgs: string) {
    if (libgs.length !== 0) {
        return libgs;
    }

    try {
        let path = '/usr/local/share/ghostscript';
        let children = fs.readdirSync(path);
        path = `${path}/${children[children.length - 1]}/lib`;
        children = fs.readdirSync(path);
        const lib = children.find((f) =>
            f.startsWith('libgs.so') || f.startsWith('libgs.dylib')
        );
        return `${path}/${lib}`;
    } catch (e) {
        console.info('Ghostscript could not be found', e);
        return libgs;
    }
}

function handleTexToSvg(
    options: viteTexLoaderOptionsMandatory,
    config: ReducedResolvedConfig,
    filePath: string,
): string | undefined {
    const paths = getPaths(config, filePath, 'svg');
    if (newVersion(paths.fileOriginPath, paths.fileDestPath)) {
        try {
            const libgsPath = findGhostScript(options.LIBGS);
            const libgs = libgsPath ? `export LIBGS=${libgsPath};` : '';
            const cmd = [
                `mkdir -p "${paths.tmpDirPath}"`,
                `mkdir -p "${paths.dirDestPath}"`,
                `latex ${options.svgLatexCliOptions} -output-directory="${paths.tmpDirPath}" -output-format=dvi "${paths.fileOriginPath}"`,
                `dvisvgm ${options.svgDvisvgmCliOptions} -o "${paths.fileDestPath}" "${paths.tmpDirPath}/${paths.filenameWithoutTexExtension}.dvi"`,
            ].join(' && ');
            childProcess.execSync(`${libgs} ${cmd}`);

            // Add a prefix to auto generated tag ids
            // This prevents conflicts between svgs when used on a same web page
            if (options.dvisvgmPrefix) {
                let fileContent = fs.readFileSync(paths.fileDestPath)
                    .toString();
                const matches = [...(fileContent.matchAll(/id='([^']+)'/g))]
                    .map(
                        (m) => m[1],
                    );
                for (const m of matches) {
                    fileContent = fileContent.replaceAll(
                        `id='${m}'`,
                        `id='${options.dvisvgmPrefix}${m}'`,
                    );
                    fileContent = fileContent.replaceAll(
                        `xlink:href='#${m}'`,
                        `xlink:href='#${options.dvisvgmPrefix}${m}'`,
                    );
                }
                fs.writeFileSync(paths.fileDestPath, fileContent);
            }
        } catch (e) {
            let stdout: string = '';
            if (hasStdout(e)) {
                stdout = e.stdout.toString();
            }
            throw new Error(
                `Couldn't convert "${paths.fileOriginPath}" to SVG: ${stdout}`,
            );
        }
    }

    return `export const uri = "/${paths.uri}"; export const raw = \`${
        readContent(paths.fileDestPath)
    }\`; export default uri;`;
}

function handleTexToPdf(
    options: viteTexLoaderOptionsMandatory,
    config: ReducedResolvedConfig,
    filePath: string,
): string | undefined {
    const paths = getPaths(config, filePath, 'pdf');
    if (newVersion(paths.fileOriginPath, paths.fileDestPath)) {
        try {
            const libgsPath = findGhostScript(options.LIBGS);
            const libgs = libgsPath ? `export LIBGS=${libgsPath};` : '';
            const cmd = [
                `mkdir -p "${paths.tmpDirPath}"`,
                `mkdir -p "${paths.dirDestPath}"`,
                `pdflatex ${options.pdfPdflatexCliOptions} -output-directory="${paths.tmpDirPath}" "${paths.fileOriginPath}"`,
                `mv "${paths.tmpDirPath}/${paths.filenameWithoutTexExtension}.pdf" "${paths.fileDestPath}"`,
            ].join(' && ');
            childProcess.execSync(`${libgs} ${cmd}`);
        } catch (e) {
            let error: string = '';
            if (hasStdout(e)) {
                error = e.stdout.toString();
            }
            throw new Error(
                `Couldn't convert "${paths.fileOriginPath}" to PDF: ${error}`,
            );
        }
    }

    return `export default "/${paths.uri}";`;
}

export function load(
    options: viteTexLoaderOptions,
    config: ReducedResolvedConfig,
    filePath: string,
) {
    // Give priority to the options, otherwise use the env variable
    if (options.LIBGS === undefined && process.env.LIBGS) {
        options.LIBGS = process.env.LIBGS;
    }
    const mandatoryOptions = convertOptionsToMandatory(options);

    let match = filePath.match(/(.+\.tex)\?svg(&.*)?$/);
    if (match && match[1]) {
        const map: Map<string, string> | null = match[2]
            ? readUriParams(match[2])
            : null;
        if (map) {
            mandatoryOptions.dvisvgmPrefix = map.get('idPrefix');
        }
        return handleTexToSvg(
            mandatoryOptions,
            config,
            match[1],
        );
    }
    match = filePath.match(/(.+\.tex)\?pdf-uri(&.*)?$/);
    if (match && match[1]) {
        return handleTexToPdf(
            mandatoryOptions,
            config,
            match[1],
        );
    }
    // We don't support the file/module requested
    return undefined;
}
